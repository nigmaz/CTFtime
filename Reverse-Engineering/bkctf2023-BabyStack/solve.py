program = bytes.fromhex('0006000101060c0d010600080105010622380106ff00010801020106313001010106694e01000007000001060c0d01062d410102010600080105010622380106552201010106ff00010801020106333201010106326a0100000700000106493001060008010501063e5e0106ff00010801020106353401010106450a01000007000001063b2001060008010501066b2d0106ff000108010201063736010101065b7801000007000001062b79010600080105010670410106ff00010801020106393801010106374501000007000001067879010600080105010634410106ff00010801020106626101010106550a01000007000001066a3601060008010501062d010106ff00010801020106646301010106581e0100000700000106751b01060008010501063b170106ff000108010201066665010101060f190100000700000106777c010600080105010645300106ff00010801020106686701010106760301000007000001060f3701060008010401063b23010600ff0108010201066a69010101064a12010000070000')

i = 0

stack = []

while i < len(program):
    step = 0
    word = -1
    byte = -1
    id = hex(i)[2:].ljust(6, ' ')
    print(id, end='')

    if program[i + 1] == 6:
        step = 4
        word = program[i + 3] + (program[i + 2] << 8)
        byte = program[i]
    else:
        step = 2
        byte = program[i]

    match program[i + 1]:
        case 0:
            print(f'EQUAL')
        case 1:
            print(f'XOR')
        case 2:
            print(f'ADD')
        case 3:
            print(f'SUBTRACT')
        case 4:
            print(f'SHL')
        case 5:
            print(f'SHR')
        case 6:
            print(f'PUSH {hex(word)}')
        case 7:
            print(f'POP')
        case 8:
            print(f'AND')

        case _:
            print(f'Invalid opcode {program[i + 1]}')
            break

    i += step
